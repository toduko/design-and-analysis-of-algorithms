\chapter{Сортиране}

\section{Каква задача решаваме?}

Ще формулираме задачата във по-общ вариант.
Имаме някаква преднаредба (рефлексивна и транзитивна релация) $\leq_A$ върху множество $A$.
Даден ни е масив $B[1 \dots n]$ със елементи от $A$ и търсим пермутация $B'[1 \dots n]$ на $B[1 \dots n]$, за която:
\[
    B'[1] \leq_A B'[2] \leq_A \dots \leq_A B'[n].
\]
На нас обикновено ще ни интересува частния случай $(A, \leq_A) = (\Z, \leq)$.
Ще разгледаме малко по-подробно два сортиращи алгоритъма -- за сортиране чрез сливане и за бързо сортиране.

\section{Сортиране чрез сливане}
Нека си представим, че искаме да сортираме редицата $\opair{6, 7, 5, 4, 8, 2, 3, 1}$.
Можем да направим следното разделение на подзадачи за сортиране:
\begin{center}
    \begin{forest}
        [$\opair{6, 7, 5, 4, 8, 2, 3, 1}$
            [$\opair{6, 7, 5, 4}$ [$\opair{6, 7}$ [$\opair{6}$] [$\opair{7}$]] [$\opair{5, 4}$ [$\opair{5}$] [$\opair{4}$]]] [$\opair{8, 2, 3, 1}$ [$\opair{8, 2}$ [$\opair{8}$] [$\opair{2}$]] [$\opair{3, 1}$ [$\opair{3}$] [$\opair{1}$]]]
        ]
    \end{forest}
\end{center}
Сега това, което трябва да направим, е да започнем да сливаме масивите:
\begin{center}
    \begin{forest}
        for tree={grow'=north}
        [$\opair{1, 2, 3, 4, 5, 6, 7, 8}$ [$\opair{4, 5, 6, 7}$ [$\opair{6, 7}$ [$\opair{6}$] [$\opair{7}$]] [$\opair{4, 5}$ [$\opair{5}$] [$\opair{4}$]]] [$\opair{1, 2, 3, 8}$ [$\opair{2, 8}$ [$\opair{8}$] [$\opair{2}$]] [$\opair{1, 3}$ [$\opair{3}$] [$\opair{1}$]]]]
    \end{forest}
\end{center}
Ако имахме функция $\mathtt{Merge}$, която приемаше два сортирани масива $A[1 \dots n], B[1 \dots m]$ и връщаше масив $C[1 \dots n + m]$, който съдържа елементите на $A[1 \dots n]$ и $B[1 \dots m]$ в сортиран ред, то тогава щяхме да получим следния алгоритъм за сортиране:
\lstinputlisting{algorithms/merge-sort.txt}
Ще докажем това с индукция по $n$:
\begin{itemize}
    \item В базовия случай $n = 1$.
          Всеки едноелементен масив е сортиран и ние коректно ще върнем копие на $A[1 \dots n]$.
    \item Нека сега $n > 1$.
          По (ИП) двете извиквания на $\mathtt{MergeSort}$ ще сортират $A[1 \dots \lfloor \frac{n}{2} \rfloor]$ и $A[\lfloor \frac{n}{2} \rfloor + 1 \dots n]$.
          След това по допускане извикването на $\mathtt{Merge}$ коректно ще ги слее в нов сортиран масив и след това алгоритъмът ще върне този масив.
\end{itemize}
Ако $\mathtt{Merge}$ завършва за време $T_M(n)$, то сложността на $\mathtt{MergeSort}$ може да се опише с рекурентното уравнение:
\[
    T(n) = 2 T(\frac{n}{2}) + T_M(n).
\]
Нещо повече, ако покажем алгоритъм $\mathtt{Merge}$ със линейна сложност по време, то тогава:
\[
    T(n) = 2 T(\frac{n}{2}) + \Theta(n) \asymp n \log(n).
\]

\newpage

Ето алгоритъм със сложност $\Theta(n + m)$, който слива два сортирани масива:
\lstinputlisting{algorithms/merge.txt}

Нека сега формулираме инвариантът (той ще бъде един за всички цикли), чието доказателство оставяме на читателя:
\begin{invariant}
    При всяко достигане на условието за край на цикъла на редове $7, 16$ и $21$ е изпълнено, че:
    \begin{itemize}
        \item $C[1 \dots i - 1]$ съдържа елементите на $A[1 \dots l_A - 1]$ и $B[1 \dots l_B - 1]$, и то в сортиран ред;
        \item $l_A$ е индексът на най-малкия елемент на $A[1 \dots n]$, който още не е копиран в $C[1 \dots n + m]$;
        \item $l_B$ е индексът на най-малкия елемент на $B[1 \dots m]$, който още не е копиран в $C[1 \dots n + m]$.
    \end{itemize}
\end{invariant}

\section{Бързо сортиране}
Сега ще покажем още една идея за сортиране.
Нека отново ни е дадена редицата $\opair{6, 7, 5, 4, 8, 2, 3, 1}$.
Ако можехме да пренаредим масива така, че всички елементи, които са по-малки от $5$ да са вляво от $5$ и останалите да бъдат вдясно от $5$, то тогава щяхме да трябва да сортираме двете по-малки редици.
Да кажем, след пренареждането получаваме редицата $\opair{4, 2, 1, 3, 5, 7, 6, 8}$.
Тогава ще трябва само да сортираме редиците $\opair{4, 2, 1, 3}$ и $\opair{7, 6, 8}$.
По формално, нека си представим, че имаме алгоритъм $\mathtt{Partition}$, която приема целочислен масив $A[1 \dots n]$ и го пренарежда така, че да има индекс $pp$, за което:
\begin{itemize}
    \item $A[i] < A[pp]$ за всяко $1 \leq i < pp$;
    \item $A[i] \geq A[pp]$ за всяко $pp \leq i \leq n$,
\end{itemize}
и след това връща този индекс $pp$.

Тогава можем да получим сортиращ алгоритъм по следния начин:
\lstinputlisting{algorithms/quicksort.txt}
Да докажем, че $\mathtt{Quicksort}(A[1 \dots n])$ сортира $A[1 \dots n]$ с индукция по $n$:
\begin{itemize}
    \item В базовия случай $n \leq 1$, откъдето масивът е сортиран.
    \item Нека сега $n > 1$.
          По допускане след извикването на $\mathtt{Partition}$:
          \begin{itemize}
              \item $A[i] < A[pp]$ за всяко $1 \leq i < pp$;
              \item $A[i] \geq A[pp]$ за всяко $pp \leq i \leq n$,
          \end{itemize}
          Тогава по (ИП) алгоритъмът коректно ще сортира масивите $A[1 \dots pp - 1]$ и $A[pp + 1 \dots n]$.
\end{itemize}

Ще покажем, че $\mathtt{Partition}$ може да се имплементира със сложност $\Theta(n)$.
Тук обаче сложността на сортиращия алгоритъм зависи изцяло от това какво е $pp$.
В най-лошия случай $pp = 1$ или $pp = n$ и тогава ще имаме рекурентното уравнение:
\[
    T(n) = T(n - 1) + T(1) + \Theta(n) \asymp n^2.
\]
В средния случай се оказва, че сложността е $n \log(n)$.
На читателя оставяме да покаже, че:
\[
    T(n) = \frac{1}{n} \left( \sum\limits_{k = 1}^{n - 1} T(k) + T(n - k) \right) + \Theta(n) \asymp n \log(n).
\]

Остава само да направим имплементация на $\mathtt{Partition}$ със сложност $\Theta(n)$:
\lstinputlisting{algorithms/partition.txt}
На читателя оставяме доказателството на следния:
\begin{invariant}
    При всяко достигане на проверката за край на цикъла на ред $5$ е изпълнено, че:
    \begin{itemize}
        \item $A[j] < pivot$ за всяко $1 \leq j < pp$;
        \item $A[j] \geq pivot$ за всяко $pp \leq j < i$.
    \end{itemize}
\end{invariant}

Функцията $\mathtt{Partition}$ е много удобна.
Чрез нея можем да намираме $k$-ти по големина елемент на масив с уникални елементи по следния начин:
\lstinputlisting{algorithms/select.txt}
Ще докажем, че $\mathtt{Select}(A[1 \dots n], k)$ връща $k$-тия по големина елемент на $A[1 \dots n]$ с индукция относно $n$:
\begin{itemize}
    \item В базовия случай $n = 1$, откъдето след извикването на $\mathtt{Partition}$ ще имаме $pp = k = 1$ и алгоритъмът коректно ще върне $A[k]$.
    \item Нека сега $n > 1$.
          След извикването на $\mathtt{Partition}$:
          \begin{itemize}
              \item $A[i] < A[pp]$ за всяко $1 \leq i < pp$;
              \item $A[i] \geq A[pp]$ за всяко $pp \leq i \leq n$.
          \end{itemize}
          Нека сега разгледаме трите случая:
          \begin{itemize}
              \item[1 сл.] Ако $k = pp$, то понеже $A[pp]$ е $pp$-тия по големина елемент, алгоритъмът ще върне правилният отговор.
              \item[2 сл.] Ако $k < pp$, то е достатъчно да намерим $k$-тия по големина елемент на масива $A[1 \dots pp - 1]$, тъй като там са елементите, по-малки от $A[pp]$.
                    По (ИП) ще получим коректен отговор.
              \item[3 сл.] Ако $k > pp$, то е достатъчно да намерим $(k - pp)$-тия (понеже махаме първите $pp$ елемента на $A[1 \dots n]$) по големина елемент на масива $A[pp + 1 \dots n]$, тъй като там са елементите, по-големи от $A[pp]$.
                    По (ИП) ще получим коректен отговор.
          \end{itemize}
\end{itemize}
Тук отново сложността зависи от стойността на $pp$, която получаваме.
За съжаление, отново в най-лошия случай имаме:
\[
    T(n) = T(n - 1) + n \asymp n^2.
\]
В средния случай получаваме:
\[
    T(n) = \frac{1}{n} \sum\limits_{k = 1}^{n - 1} T(k) + n.
\]
Сега ще покажем, че в средния случай:
\[
    T(n) \asymp n.
\]
Първо, можем да умножим по $n$ и от двете страни и получаваме:
\[
    n T(n) = \sum\limits_{k = 1}^{n - 1} T(k) + n^2.
\]
Тогава ако заместим $n$ с $n - 1$ и извадим, ще получим:
\[
    n T(n) - (n - 1) T(n - 1) = T(n - 1) + n^2 - (n - 1)^2 = T(n - 1) + 2n - 1.
\]
Но това е еквивалентно на:
\[
    n T(n) = n T(n - 1) + 2n - 1.
\]
Сега разделяме на $n$ и получаваме:
\[
    T(n) = T(n - 1) + 2 - \frac{1}{n} = T(n - 2) + 2 + 2 - \frac{1}{n} - \frac{1}{n - 1} = \dots = T(0) + 2n - \sum\limits_{k = 1}^n \frac{1}{k} \asymp n.
\]

\section{Задачи}

\begin{problem}
Да се напише колкото се може по-бърз алгоритъм, който приема масив от различни цели числа $A[1 \dots n]$ с $n \geq 3$, за който има $1 < i < n$ такова, че $A[1 \dots i]$ е сортиран възходящо и $A[i \dots n]$ е сортиран низходящо, и връща това $i$.
След това да се докаже неговата коректност, и да се изследва сложността му по време.
\end{problem}

\begin{problem}
Да се напише колкото се може по-бърз алгоритъм, който при подаден сортиран целочислен масив $A[1 \dots n]$ и число $t$, което се намира в масива, връща най-малкият и най-големият индекс, на които $t$ се намира в $A[1 \dots n]$.
След това да се докаже неговата коректност, и да се изследва сложността му по време.
\end{problem}

\begin{problem}
Да се напише колкото се може по-бърз алгоритъм, който при подаден сортиран целочислен масив $A[1 \dots n]$ и числа $k \geq 2$ и $t$, връща дали има $1 \leq i_1 < i_2 < \dots < i_k \leq n$, за които:
\[
    A[i_1] + A[i_2] + \dots + A[i_k] = t.
\]
След това да се докаже неговата коректност, и да се изследва сложността му по време.
\end{problem}

\begin{problem}
За $a, b, x \in \mathbb{Z}$ казваме, че $a$ е по-близо от $b$ до $x$, ако:
\[
    |a - x| < |b - x| \lor (|a - x| = |b - x| \: \& \: a < b).
\]
Да се напише колкото се може по-бърз алгоритъм, който приема целочислен масив $A[1 \dots n]$, и връща най-близките $k$ на брой числа до $t$ в $A[1 \dots n]$.
След това да се докаже неговата коректност, и да се изследва сложността му по време.
Може ли да се напише по-бърз алгоритъм при предположение че $A[1 \dots n]$ е сортиран?
\end{problem}

\begin{problem}
Да се напише колкото се може по-бърз алгоритъм, който приема масив $A[1 \dots n]$, съставен от числата $0, 1$ и $2$, и го сортира.
След това да се докаже неговата коректност, и да се изследва сложността му по време.
\end{problem}

\begin{problem}
Да се напише колкото се може по-бърз алгоритъм, който приема масив $I[1 \dots n]$, съставен от двойки числа, които представят някакъв затворен интервал от цели числа ($[a, b]$ за някои $a, b \in \mathbb{Z}$), и връща нов масив, в който са сляти всички интервали с непразно сечение.
След това да се докаже неговата коректност, и да се изследва сложността му по време.
\end{problem}

\begin{problem}
Да се напише колкото се може по-бърз алгоритъм, който приема целочислен масив $A[1 \dots n]$, и връща нов масив от квадратите на $A[1 \dots n]$, който е сортиран.
След това да се докаже неговата коректност, и да се изследва сложността му по време.
\end{problem}

\begin{problem}
Да се напише колкото се може по-бърз алгоритъм, който приема целочислен масив $A[1 \dots 2n]$, и връща:
\[
    \min\{ \max \{ A'[2i] + A'[2i - 1] \mid 1 \leq i \leq n \} \mid A'[1 \dots 2n] \text{ е пермутация на } A[1 \dots 2n] \}.
\]
След това да се докаже неговата коректност, и да се изследва сложността му по време.
\end{problem}

\begin{problem}
Да се напише колкото се може по-бърз алгоритъм, който приема два целочислени масива $A[1 \dots n]$ и $B[1 \dots n]$, и връща:
\begin{align*}
    \min \{ \sum\limits_{i = 1}^n |A'[i] - B'[i]| \mid & A'[1 \dots n] \text{ е пермутация на } A[1 \dots n] \text{ и} \\
                                                       & B'[1 \dots n] \text{ е пермутация на } B[1 \dots n] \}.
\end{align*}
След това да се докаже неговата коректност, и да се изследва сложността му по време.
\end{problem}

\begin{problem}
Да се напише колкото се може по-бърз алгоритъм, който приема целочислен масив $A[1 \dots n]$ и го подрежда така, че всички отрицателни числа да са вляво от всички неотрицателни.
След това да се докаже неговата коректност и да се изследва сложността му по време и памет.
\end{problem}

\begin{problem}
Статиите на даден учен са номерирани от $1$ до $n$.
Индексът на Хирш или $h$-индексът за този учен ще наричаме най-голямото число $k$, за което поне $k$ негови статии са цитирани поне $k$ пъти.
Да се състави алгоритъм, който приема масив $C[1 \dots n]$ от броя на цитиранията на статиите на този учен и връща неговият $h$-индекс.
\end{problem}
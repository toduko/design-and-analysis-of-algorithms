\section{Два алгоритъма}

Ще започнем с два често срещани алгоритъма, които се възползват от това, че данните идват сортирани:
\begin{itemize}
    \item двоично търсене;
    \item алгоритъма за задачата \textbf{2SUM}.
\end{itemize}

Нека започнем с алгоритъма за двоично търсене:
\lstinputlisting{algorithms/binary-search.txt}

При подаден сортиран целочислен масив $A[1 \dots n]$ и цяло число $v$, функцията $\mathtt{BinarySearch}(A[1 \dots n], v)$ ще върне индекс на $A[1 \dots n]$, в който се намира $v$, ако има такъв, иначе ще върне $-1$.

\begin{invariant}
    При всяко достигане на проверката за край на цикъла на ред $6$ имаме, че стойността $v$ не се намира измежду двата масива $A[1 \dots l - 1]$ и $A[r + 1 \dots n]$.
\end{invariant}

\begin{proof}
    \phantom{1}

    \textbf{База.}
    При първото достигане имаме, че $l = 1$ и $r = n$.
    Наистина $v$ не се намира измежду двата масива $A[1 \dots 1 - 1]$ и $A[n + 1 \dots n]$.

    \textbf{Поддръжка.}
    Нека твърдението е изпълнено за някое непоследно достигане на проверката за край на цикъла.
    Тогава $v$ не се намира измежду $A[1 \dots l - 1]$ и $A[r + 1 \dots n]$, и понеже достигането е непоследно, $l \leq r$.
    Тогава $m = \Bigl\lfloor \frac{l + r}{2} \Bigr\rfloor$, откъдето ${l \leq m \leq r}$.
    Трябва да разгледаме следните три случая:
    \begin{itemize}
        \item[1 сл.] $A[m] = v$ -- това няма как да е изпълнено понеже достигането е нефинално;
        \item[2 сл.] $A[m] < v$ -- понеже $A[1 \dots n]$ е сортиран, няма как $v$ да се намира измежду $A[1 \dots m]$, откъдето $v$ не се намира измежду $A[1 \dots \underbrace{\mathtt{m + 1}}_{l_{new}} - 1]$ и $A[r + 1 \dots n]$;
        \item[3 сл.] $A[m] > v$ -- напълно дуален на 2 сл.
    \end{itemize}

    \textbf{Терминация.}
    От цикъла винаги ще излезем, защото или ще открием $v$, или величината $r - l$ ще намалява, докато не стане отрицателна.
    Излизането става по два начина:
    \begin{itemize}
        \item Ако не е изпълнено условието на ред $6$ т.е. $l > r$, то тогава $l - 1 \geq r$ и понеже $v$ не се намира измежду $A[1 \dots l - 1]$ и $A[r + 1 \dots n]$, $v$ не се намира във $A[1 \dots n]$.
              Накрая алгоритъмът ще върне $-1$, което наистина е желания резултат.
        \item Ако е изпълнено е условието на ред $9$ т.е. $A[m] = v$, то тогава алгоритъмът коректно връща $m$.
    \end{itemize}
\end{proof}

Сега ще разгледаме алгоритъм за задачата \textbf{2SUM}.

Ще искаме алгоритъм, който при подаден сортиран целочислен масив $A[1 \dots n]$ и цяло число $t$ разпознава дали има $1 \leq i < j \leq n$, за които:
\[
    A[i] + A[j] = t.
\]
Такива двойки $(A[i], A[j])$ ще наричаме \textit{диади}.

\newpage

Алгоритъмът е следния:
\lstinputlisting{algorithms/two-sum.txt}

\begin{invariant}
    При всяко достигане на проверката за край на цикъла на ред $5$, всички диади са в $A[l \dots r]$.
\end{invariant}

\begin{proof}
    \phantom{1}

    \textbf{База.}
    При първото достигане имаме, че $l = 1$ и $r = n$.
    Тогава твърдението е тривиално изпълнено.

    \textbf{Поддръжка.}
    Нека твърдението е изпълнено за някое непоследно достигане на проверката за край на цикъла.
    Тогава всички диади са в $A[l \dots r]$ и $l < r$.
    Разглеждаме три случая:
    \begin{itemize}
        \item[1 сл.] $A[l] + A[r] = t$ -- това няма как да е изпълнено понеже достигането е нефинално;
        \item[2 сл.] $A[l] + A[r] < t$ -- тогава понеже $A[1 \dots n]$ е сортиран, за всяко $l \leq i \leq r$ имаме, че $A[l] + A[i] \leq A[l] + A[r] < t$, което означава, че $l$ не участва в никоя диада във $A[l \dots r]$, следователно всички диади се намират в $A[\underbrace{l + 1}_{l_{new}} \dots r]$;
        \item[3 сл.] $A[l] + A[r] > t$ -- напълно дуален на 2 сл.
    \end{itemize}

    \textbf{Терминация.}
    От цикъла винаги ще излезем, защото или ще открием $v$, или величината $r - l$ ще намалява, докато не стане $0$.
    Излизането става по два начина:
    \begin{itemize}
        \item Ако не е изпълнено условието на ред $4$ т.е. $l \geq r$, то тогава няма диади в $A[1 \dots n]$, и алгоритъмът коректно ще върне $\F$.
        \item Ако е изпълнено условието на ред $5$ т.е. $A[l] + A[r] = t$, то тогава алгоритъмът връща $\T$ т.е. точно това, което искаме.
    \end{itemize}
\end{proof}

Двата алгоритъма са доста подобни, използват една често срещана техника за търсене в дадено множество от елементи.
Търсенето започва с цялото множество и то постепенно се смалява.
Разбира се, тук разгледаните алгоритми имат разлика в сложността, поради разликата в стесняването:
\begin{itemize}
    \item първият алгоритъм има сложност $O(\log(n))$, понеже разликата между $r$ и $l$ винаги намалява двойно;
    \item вторият алгоритъм има сложност $O(n)$, понеже разликата между $r$ и $l$ винаги намалява с единица.
\end{itemize}
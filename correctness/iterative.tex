\section{Какво имаме предвид под коректност?}

За целите на този курс един алгоритъм ще наричаме \textbf{коректен}, ако завършва при всякакви входни данни и връща правилен резултат при всякакви входни данни

\begin{remark}
    Въпреки че ние ще имаме това разбиране в курса, на практика тези изисквания невинаги са изпълнени:
    \begin{itemize}
        \item разглеждат се алгоритми, които могат и да не завършват за някои входни данни -- от теоретична гледна точка са интересни за хората, които се занимават с теорията на изчислимостта;
        \item разглеждат се алгоритми, които много често (но не винаги) връщат правилния резултат -- обикновено това се прави с цел бързодействие.
    \end{itemize}
\end{remark}

\section{Едно \textit{``ново''} понятие -- инвариант}

Специално за итеративните алгоритми се въвежда ново понятие - \textbf{инвариант}.
Това са специални твърдения, свързани с цикъла.

В най-общият случай (за алгоритми) се формулират по следния начин:
\begin{center}
    ``При $k$-тото достигане на ред $l$ (ако има няколко инструкции казваме преди/след коя се намираме) в алгоритъма $\mathfrak{A}$ е изпълнено \textit{някакво твърдение, зависещо от $k$ и променливите, използвани в $\mathfrak{A}$}''.
\end{center}
Доказателството на такива твърдения протича с добре познатата индукция.
Първо доказваме базата т.е. какво се случва при първото достигане на цикъла.
Индуктивното предположение и индуктивната стъпка се обединяват в \textit{``нова''} фаза, наречена \textbf{поддръжка}.
Довършителните разсъждения, които по принцип се намират след доказването на твърдението чрез индукция, ще наричаме \textbf{терминация}.
Накрая показваме, че винаги ще излезнем от цикъла (\textbf{финитност}).
Обикновено това ще го смятаме за очевидно (най-вече за $\mathtt{for}$-цикли).

\begin{warning}
    Това, за което се използват инвариантите, е да се докаже коректността на ЕДИН цикъл, не на цял алгоритъм.
    Когато в алгоритъма ни има няколко цикъла, на всеки от тях трябва да съответства по един инвариант.
\end{warning}

\section{Инвариантите в действие}

Нека разгледаме следния алгоритъм за степенуване на $2$:
\lstinputlisting{algorithms/pow2.txt}

\begin{invariant}
    При всяко достигане на проверката за край на цикъла (на ред $4$) е изпълнено, че $r = 2^{i - 1}$.
\end{invariant}
\begin{proof}
    \phantom{1}

    \textbf{База.}
    Наистина при първото достигане имаме, че $i = 1$ и от там $r = 1 = 2^{i - 1}$.

    \textbf{Поддръжка.}
    Нека при някое непоследно достигане твърдението е изпълнено.
    Тогава преди следващото достигане на проверката на $r$ присвояваме $2r$, като знаем, че преди $r$ е бил $2^{i - 1}$, и след това на $i$ присвояваме $i + 1$.
    Така е ясно, че при новото достигане на проверката $r$ ще стане $2 \cdot 2^{i_{old} - 1} = 2^{i_{old}} = 2^{i - 1}$.

    \textbf{Терминация.}
    Ако е изпълнено условието за край на цикъла, то тогава $i = n + 1$, откъдето ще върнем $r = 2^{(n + 1) - 1} = 2^n$.

    \textbf{Финитност.}
    Величината $n - i$ започва с $n - 1$, и намалява с $1$, докато не стигне $-1$, когато ще излезнем от цикъла.
    Следователно алгоритъмът винаги завършва.
\end{proof}

\section{С инвариантите трябва да се внимава}

Един от често срещаните капани, в които попадат хората, е да не си формулират инвариантът добре.
Много е важно инвариант да дава достатъчна информация за това което наистина се случва в алгоритъма.
За целта ще разгледаме един пример:
\lstinputlisting{algorithms/selection-sort.txt}

На интуитивно ниво е ясно какво прави кода.
Намира най-малкия елемент, и го слага на първо място.
След това намира втория най-малък елемент, и го слага на второ място, и т.н.

Нещо, което някои биха се пробвали да направят за първия цикъл, е следното:
\begin{center}
    \textit{При всяко достигане на проверката за край на цикъла на ред $3$ подмасивът $A[1 \dots i - 1]$ е сортиран.}
\end{center}

Проблемът с това твърдение, е че може много лесно да се измисли алгоритъм, за който това твърдение е изпълнено, и изобщо не сортира елементите в масива:
\lstinputlisting{algorithms/trust-me-it-sorts.txt}

Очевидно този за този алгоритъм горната инвариант е изпълнена, но той е безсмислен.
Получаваме сортиран масив, но за сметка на това губим цялата информация, която сме имали за него.

Нещо друго, което е важно да се направи, е първо да се формулира инвариант за вътрешния цикъл, и после за външния, като тънкият момент тук е, че ще ни трябват допускания за първият инвариант.
Идеята е, че външния цикъл разчита на вътрешния да си свърши работата, и обратно вътрешния разчита (не винаги) на външния преди това да си е свършил работата.

Нека покажем как трябва да станат инвариантите, като доказателството оставяме за упражнение на читателя.
Нека $A^*[1 \dots n]$ е първоначалната стойност на входния масив.
\begin{invariant}[вътрешен цикъл]
    При всяко достигане на проверката за край на цикъла на ред $5$ имаме, че $m$ е индексът на най-малкия елемент в масива $A[i \dots j - 1]$.
\end{invariant}

\begin{invariant}[външен цикъл]
    При всяко достигане на проверката за край на цикъла на ред $2$ имаме, че масивът $A[1 \dots i - 1]$ съдържа сортирани първите $i - 1$ по големина елементи на $A^*[1 \dots n]$, като останалите са в $A[i \dots n]$.
\end{invariant}

Обикновено в доказателството на коректност на алгоритми най-трудното е да се формулира инвариантът.
Ако човек има добре формулирана инвариант, доказателството e на първо място възможно, а на второ -- по-лесно.

\section{Подход при задачи с вече даден алгоритъм}

Нека разгледаме следния алгоритъм:
\lstinputlisting{algorithms/foo.txt}
Питаме се какво връща той?

Обикновено в такива задачи трябва да се изпробва алгоритъма върху няколко стойности.
Можем да забележим, че:
\begin{itemize}
    \item $\mathtt{foo}(0)$ връща $0$;
    \item $\mathtt{foo}(1)$ връща $1$;
    \item $\mathtt{foo}(2)$ връща $8$ и така нататък.
\end{itemize}

Вече можем да видим какво прави алгоритъмът -- $\mathtt{foo}(a)$ връща $a^3$.
Нека сега докажем това:
\begin{invariant}
    При всяко достигане на проверката за край на цикъла на ред $5$ е изпълнено, че:
    \begin{itemize}
        \item $x = 6 (1 + i)$;
        \item $y = 3i^2 + 3i + 1$;
        \item $z = i^3$.
    \end{itemize}
\end{invariant}
\begin{proof}
    \phantom{1}

    \textbf{База.}
    При първото достигане имаме, че:
    \begin{itemize}
        \item $i = 0$;
        \item $x = 6 = 6 \cdot 1 = 6 (1 + 0) = 6 (1 + i)$;
        \item $y = 1 = 3 \cdot 0^2 + 3 \cdot 0 + 1 = 3i^2 + 3i + 1$;
        \item $z = 0 = 0^3 = i^3$.
    \end{itemize}

    \textbf{Поддръжка.}
    Нека твърдението е изпълнено за някое непоследно достигане на проверката за край на цикъла.
    Тогава при влизане в тялото на цикъла:
    \begin{itemize}
        \item $z$ ще стане $z + y \stackrel{\text{(ИП)}}{=} i^3 + 3i^2 + 3i + 1 = (\underbrace{i + 1}_{\text{ново } i})^3$;
        \item $y$ ще стане $y + x \stackrel{\text{(ИП)}}{=} 3i^2 + 3i + 1 + 6 + 6i = 3(\underbrace{i + 1}_{\text{ново } i})^2 + 3(\underbrace{i + 1}_{\text{ново } i}) + 1$;
        \item $x$ ще стане $x + 6 \stackrel{\text{(ИП)}}{=} 6(1 + i) + 6 = 6(1 + \underbrace{i + 1}_{\text{ново } i})з$.
    \end{itemize}

    \textbf{Терминация.}
    В последното достигане на проверката за край на цикъла имаме, че $i = a$, и тогава на ред $12$ алгоритъмът ще върне $z = a^3$.

    \textbf{Финитност.} (от тук нататък повечето няма да ги пишем)
    Величината $a - i$ започва с $a$, и намалява с $1$, докато не стигне $0$, когато ще излезнем от цикъла.
    Следователно алгоритъмът винаги завършва.
\end{proof}

\newpage

Нека разгледаме още един такъв пример:
\lstinputlisting{algorithms/quux.txt}

Искаме да видим какво връща $\mathfrak{quux}(A[1 \dots n])$.
Тук най-трудното, което трябва да се направи, е да се определи какво връщат $\mathfrak{bar}$ и $\mathfrak{foo}$:
\begin{itemize}
    \item $\mathfrak{bar}(n) = \sqrt{n ^ 2} = | n |$;
    \item $\mathfrak{foo}(x, y) = \frac{x + y + |x - y|}{2}  = \max\{ x, y \}$:
          \begin{itemize}
              \item ако $x \geq y$, то $\frac{x + y + |x - y|}{2} = \frac{x + y + x - y}{2} = \frac{2x}{2} = x = \max\{ x, y \}$,
              \item ако $x < y$, то $\frac{x + y + |x - y|}{2} = \frac{x + y + y - x}{2} = \frac{2y}{2} = y = \max\{ x, y \}$.
          \end{itemize}
\end{itemize}

Като знаем какво правят $\mathfrak{bar}$ и $\mathfrak{foo}$, можем да забележим, че $\mathfrak{quux}(A[1 \dots n])$ дава най-големия елемент на $A[1 \dots n]$:
\begin{invariant}
    При всяко достигане на проверката за край на цикъла на ред $15$ е изпълнено, че $a = \max A[1 \dots i - 1]$.
\end{invariant}

\begin{proof}
    \phantom{1}

    \textbf{База.}
    Наистина при първото достигане $a = A[1] = \max A[1 \dots i - 1]$.

    \textbf{Поддръжка.}
    Нека твърдението е изпълнено за някое непоследно достигане на проверката за край на цикъла.
    Тогава като влезем в тялото на цикъла, променливата $a$ става:
    \begin{align*}
        \mathfrak{foo}(a, A[i])  \stackrel{\text{(ИП)}}{=} \mathfrak{foo}(\max A[1 \dots i - 1], A[i]) = & \max (\max A[1 \dots i - 1], A[i])                                          \\
        =                                                                                                & \max A[1 \dots i] = \max A[1 \dots \underbrace{i + 1}_{\text{ново } i} - 1]
    \end{align*}

    \textbf{Терминация.}
    При последното достигане на проверката за край на цикъла на ред $15$ променливата $i$ ще бъде $n + 1$, откъдето функцията ще върне точно $a = \max A[1 \dots (n + 1) - 1] = \max A[1 \dots n]$, с което сме готови.
\end{proof}

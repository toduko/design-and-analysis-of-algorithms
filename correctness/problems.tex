\section{Задачи}

\begin{problem}
Даден е следният алгоритъм:
\lstinputlisting{algorithms/anon-alg1.txt}

\begin{enumerate}
    \item Какво връща той? Отговорът да се обоснове.
    \item Каква е неговата сложност по време и памет?
\end{enumerate}
\end{problem}

\newpage

\begin{problem}
Даден е следният алгоритъм:
\lstinputlisting{algorithms/fib-iter-linear.txt}

Да се докаже, че $\mathfrak{F}(n)$ връща $n$-тото число на Фибоначи.
\end{problem}

\begin{problem}
Даден е следният: алгоритъм:
\lstinputlisting{algorithms/mult.txt}

Да се докаже, че при вход $n \times n$ целочислени матрици $A, B$ и $C$ функцията $\mathtt{Mult}(A, B, C)$ записва в $C$ произведението на $A$ и $B$.
Да се намери сложността му по време и памет.
\end{problem}

\begin{problem}
Да се напише колкото се може по-бърз алгоритъм, който при подадено крайно множество от точки $P \subseteq \mathbb{Z} \cross \mathbb{Z}$, намира
\[
    \max \{ |x_1 - x_2| + |y_1 - y_2| \mid (x_1, y_1), (x_2, y_2) \in P \}.
\]
След това да се докаже неговата коректност и да се изследва сложността му по време и памет.
\end{problem}

\begin{problem}
Даден е следният алгоритъм:
\lstinputlisting{algorithms/num-slopes.txt}

Какво връща $\mathtt{NumSlopes}(A[1 \dots n])$?
Отговорът да се обоснове.
\end{problem}

\begin{problem}
Даден е следният алгоритъм:
\lstinputlisting{algorithms/kadane.txt}

Какво връща $\mathtt{Kadane}(A[1 \dots n])$?
Отговорът да се обоснове.
\end{problem}

\begin{problem}
Да се напише алгоритъм $\mathtt{Calculate}(F[0 \dots k], S[0 \dots k], n)$, който приема два целочислени масива $F[0 \dots k]$ и $S[0 \dots k]$, естествено число $n$ и връща числото $T(n)$, където:
\begin{align*}
     & T(0) = F[0]                                                                         \\
     & T(1) = F[1]                                                                         \\
     & \phantom{00000} \vdots                                                              \\
     & T(k) = F[k]                                                                         \\
     & T(n + k + 1) = S[k] \cdot T(n + k) + \dots + S[1] \cdot T(n + 1) + S[0] \cdot T(n).
\end{align*}
След това да се докаже неговата коректност, и да се изследва сложността му по време.
\end{problem}

\newpage

\begin{problem}
Даден е следният алгоритъм:
\lstinputlisting{algorithms/find-majority.txt}

Да се докаже, че при подаден целочислен масив $A[1 \dots n]$, в който има елемент с повече от $\lfloor \frac{n}{2} \rfloor$ срещания,
функцията $\mathtt{FindMajority}(A[1 \dots n])$ ще върне точно този елемент.
\end{problem}

\begin{problem}
Да се напише алгоритъм $\mathtt{IsDerivationTree}(G = \opair{\Sigma, V, S, R}, T)$, който приема безконтекстна граматика $G$, дърво $T$ и проверява дали $T$ е дърво на извод за $G$.
След това да се докаже неговата коректност и да се изследва сложността му по време и памет.
\end{problem}

\begin{problem}
Масив на Монж ще наричаме всеки двумерен масив $A[1 \dots n, 1 \dots m]$ от естествени числа, за който:
\[
    A[p, q] + A[s, t] \leq A[p, t] + A[s, q] \text{ за всички } 1 \leq p, s \leq n \text{ и } 1 \leq q, t \leq n.
\]
Да се напише алгоритъм със линейна сложност (т.е. $\Theta(n \cdot m)$), който приема двумерен масив $A[1 \dots n, 1 \dots m]$ и проверява дали е масив на Монж.
След това да се докаже неговата коректност и да се изследва сложността му по време и памет.
\end{problem}

\begin{problem}
Да се напише алгоритъм, който приема естествено число $n$ и връща булев масив $P[2 \dots n]$, за който е изпълнено, че за всяко $2 \leq i \leq n$:
\[
    P[i] \text{ е истина } \iff i \text{ е просто}.
\]
След това да се докаже неговата коректност и да се изследва сложността му по време и памет.
\end{problem}

\begin{problem}
Даден е следният алгоритъм:
\lstinputlisting{algorithms/stooge-sort.txt}
Какво прави $\mathtt{SS}(A[1 \dots n], 1, n)$ и каква е сложността на този алгоритъм по време и памет?
Обосновете отговорите си.
\end{problem}

\begin{problem}
Да се напише колкото се може по-бърз алгоритъм, който приема целочислен масив $A[1 \dots n]$ и връща масив $B[1 \dots n]$, такъв че за всяко $1 \leq i \leq n$:
\[
    B[i] = \prod\limits_{\substack{k = 1 \\ k \neq i}}^n A[i].
\]
След това да се докаже неговата коректност и да се изследва сложността му по време и памет.
\end{problem}

\begin{problem}
Да се напише колкото се може по-бърз алгоритъм, който приема целочислен масив $A[1 \dots n]$ и връща двойка $\opair{i, j}$ от различни индекси, за която:
\[
    A[i] \cdot A[j] = \max\limits_{1 \leq i' < j', \leq n} A[i'] \cdot A[j'].
\]
След това да се докаже неговата коректност и да се изследва сложността му по време и памет.
\end{problem}

\begin{problem}
Като вход е даден масив от естествени числа $H[1 \dots n]$, който представя линии между точките $(i, 0)$ и $(i, H[i])$.
Да се напише алгоритъм, който намира индексите на двете линии, които образуват контейнер, който би събрал максимално много вода.
\end{problem}

\newpage

\begin{problem}
Даден е следният алгоритъм:
\lstinputlisting{algorithms/anon-alg2.txt}
Какво връща $\mathfrak{U}(A[1 \dots n])$?
Обосновете отговора си.
\end{problem}

\begin{problem}
Дадени са $n$ на брой бензиностанции, които са подредени в кръгов маршрут.
Масивът $G[1 \dots n]$ съдържа литрите бензин в бензиностанциите, а масивът $C[1 \dots n]$ съдържа цената (в литри бензин) за придвиждане от една бензиностанция до следващата (след бензиностанция $n$ е бензиностанция $1$).
Приемаме, че имаме неограничен капацитет на резервоара.
Да се състави алгоритъм, който връща индекс на бензиностанция, от която, започвайки с празен резервоар, може да се мине през всички бензиностанции.
Ако не съществува такъв индекс, да се върне $-1$.
За простота може да си мислите, че ако има такъв индекс, ще бъде единствен.
\end{problem}
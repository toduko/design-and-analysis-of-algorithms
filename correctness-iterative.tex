\chapter{Коректност на итеративни алгоритми}

\section{Какво имаме предвид под коректност?}

За целите на този курс един алгоритъм ще наричаме \textbf{коректен}, ако завършва при всякакви входни данни и връща правилен резултат при всякакви входни данни

\begin{remark}
    Въпреки че ние ще имаме това разбиране в курса, на практика тези изисквания невинаги са изпълнени:
    \begin{itemize}
        \item разглеждат се алгоритми, които могат и да не завършват за някои входни данни -- от теоретична гледна точка са интересни за хората, които се занимават с теорията на изчислимостта;
        \item разглеждат се алгоритми, които много често (но не винаги) връщат правилния резултат -- обикновено това се прави с цел бързодействие.
    \end{itemize}
\end{remark}

\section{Едно \textit{``ново''} понятие}

Специално за итеративните алгоритми се въвежда ново понятие - \textbf{инвариант}.
Това са специални твърдения, свързани с цикъла.

В най-общият случай (за алгоритми) се формулират по следния начин:
\begin{center}
    ``При $k$-тото достигане на ред $l$ (ако има няколко инструкции казваме преди/след коя се намираме) в алгоритъма $\mathfrak{A}$ е изпълнено \textit{някакво твърдение, зависещо от $k$ и променливите, използвани в $\mathfrak{A}$}''.
\end{center}
Доказателството на такива твърдения протича с добре познатата индукция.
Първо доказваме базата т.е. какво се случва при първото достигане на цикъла.
Индуктивното предположение и индуктивната стъпка се обединяват в \textit{``нова''} фаза, наречена \textbf{поддръжка}.
Довършителните разсъждения, които по принцип се намират след доказването на твърдението чрез индукция, ще наричаме \textbf{терминация}.
Накрая показваме, че винаги ще излезнем от цикъла (\textbf{финитност}).
Обикновено това ще го смятаме за очевидно (най-вече за $\mathtt{for}$-цикли).

\begin{warning}
    Това, за което се използват инвариантите, е да се докаже коректността на ЕДИН цикъл, не на цял алгоритъм.
    Когато в алгоритъма ни има няколко цикъла, на всеки от тях трябва да съответства по един инвариант.
\end{warning}

\section{Пример}

Нека разгледаме следния алгоритъм за степенуване на $2$:
\lstinputlisting{algorithms/pow2.txt}

\begin{invariant}
    При всяко достигане на проверката за край на цикъла (на ред $4$) е изпълнено, че $r = 2^{i - 1}$.
\end{invariant}
\begin{proof}
    \phantom{1}

    \textbf{База.}
    Наистина при първото достигане имаме, че $i = 1$ и от там $r = 1 = 2^{i - 1}$.

    \textbf{Поддръжка.}
    Нека при някое непоследно достигане твърдението е изпълнено.
    Тогава преди следващото достигане на проверката на $r$ присвояваме $2r$, като знаем, че преди $r$ е бил $2^{i - 1}$, и след това на $i$ присвояваме $i + 1$.
    Така е ясно, че при новото достигане на проверката $r$ ще стане $2 \cdot 2^{i_{old} - 1} = 2^{i_{old}} = 2^{i - 1}$.

    \textbf{Терминация.}
    Ако е изпълнено условието за край на цикъла, то тогава $i = n + 1$, откъдето ще върнем $r = 2^{(n + 1) - 1} = 2^n$.

    \textbf{Финитност.}
    Величината $n - i$ започва с $n - 1$, и намалява с $1$, докато не стигне $-1$, когато ще излезнем от цикъла.
    Следователно алгоритъмът винаги завършва.
\end{proof}

\section{С инвариантите трябва да се внимава}

Един от често срещаните капани, в които попадат хората, е да не си формулират инвариантът добре.
Много е важно инвариант да дава достатъчна информация за това което наистина се случва в алгоритъма.
За целта ще разгледаме един пример:
\lstinputlisting{algorithms/selection-sort.txt}

На интуитивно ниво е ясно какво прави кода.
Намира най-малкия елемент, и го слага на първо място.
След това намира втория най-малък елемент, и го слага на второ място, и т.н.

Нещо, което някои биха се пробвали да направят за първия цикъл, е следното:
\begin{center}
    \textit{При всяко достигане на проверката за край на цикъла на ред $3$ подмасивът $A[1 \dots i - 1]$ е сортиран.}
\end{center}

Проблемът с това твърдение, е че може много лесно да се измисли алгоритъм, за който това твърдение е изпълнено, и изобщо не сортира елементите в масива:
\lstinputlisting{algorithms/trust-me-it-sorts.txt}

Очевидно този за този алгоритъм горната инвариант е изпълнена, но той е безсмислен.
Получаваме сортиран масив, но за сметка на това губим цялата информация, която сме имали за него.

Нещо друго, което е важно да се направи, е първо да се формулира инвариант за вътрешния цикъл, и после за външния, като тънкият момент тук е, че ще ни трябват допускания за първият инвариант.
Идеята е, че външния цикъл разчита на вътрешния да си свърши работата, и обратно вътрешния разчита (не винаги) на външния преди това да си е свършил работата.

Нека покажем как трябва да станат инвариантите, като доказателството оставяме за упражнение на читателя.
Нека $A^*[1 \dots n]$ е първоначалната стойност на входния масив.
\begin{invariant}[вътрешен цикъл]
    При всяко достигане на проверката за край на цикъла на ред $5$ имаме, че $m$ е индексът на най-малкия елемент в масива $A[i \dots j - 1]$.
\end{invariant}

\begin{invariant}[външен цикъл]
    При всяко достигане на проверката за край на цикъла на ред $2$ имаме, че масивът $A[1 \dots i - 1]$ съдържа сортирани първите $i - 1$ по големина елементи на $A^*[1 \dots n]$, като останалите са в $A[i \dots n]$.
\end{invariant}

Обикновено в доказателството на коректност на алгоритми най-трудното е да се формулира инвариантът.
Ако човек има добре формулирана инвариант, доказателството e на първо място възможно, а на второ -- по-лесно.

\section{Задачи}

\begin{problem}
Да се:
\begin{itemize}
    \item напише алгоритъм, който сумира числата в един масив;
    \item докаже неговата коректност;
    \item изследва сложността му по време и памет.
\end{itemize}
\end{problem}

\begin{problem}
Даден е следният алгоритъм:
\lstinputlisting{algorithms/anon-alg1.txt}

\begin{enumerate}
    \item Какво връща той? Отговорът да се обоснове.
    \item Каква е неговата сложност по време и памет?
\end{enumerate}
\end{problem}

\newpage

\begin{problem}
Даден е следният алгоритъм:
\lstinputlisting{algorithms/fib-iter-linear.txt}

Да се докаже, че $\mathfrak{F}(n)$ връща $n$-тото число на Фибоначи.
\end{problem}

\begin{problem}
Даден е следният: алгоритъм:
\lstinputlisting{algorithms/mult.txt}

Да се докаже, че при вход $n \times n$ матрици $A, B$ и $C$, функцията $\mathtt{Mult}(A, B, C)$ записва в $C$ произведението на $A$ и $B$.
Да се намери сложността му по време и памет.
\end{problem}

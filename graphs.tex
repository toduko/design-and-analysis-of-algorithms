\chapter{Алгоритми върху графи}

\section{Защо изобщо се занимаваме с графи?}

Графите са може би най-приложимата структура в областта на компютърните науки.
Тяхната моделираща мощ е несравнима с тази на останалите структури.
Те могат се използват за моделиране на:
\begin{itemize}
    \item приятелски връзки в социални мрежи;
    \item пътни мрежи в навигационни системи;
    \item йерархични системи;
    \item биологични мрежи.
\end{itemize}
Някои от задачите, които могат да решават са:
\begin{itemize}
    \item намиране на най-къс път от точка $A$ до точка $B$;
    \item намиране на съвместима наредба на дадени задачи;
    \item намиране на най-добро разписание на полети;
    \item класифициране на уебсайтове по популярност;
    \item маркетинг в социални мрежи;
    \item валидация на текст.
\end{itemize}

\section{Как представяме графите в паметта?}

В зависимост от нашите цели графите могат да бъдат представени в паметта по различни начини.
Най-използваните начини са:
\begin{itemize}
    \item \textbf{Списък на съседство}:

          За всеки връх се пазят в списък съседите му (и теглата ако има такива).
    \item \textbf{Матрица на съседство}:

          Пази се булева (може и числова ако графът е тегловен) таблица със всевъзможните комбинации от двойки върхове.
          Ако между два върха има ребро, то в съответната клетка пише единица (или теглото на реброто при тегловен граф), иначе нула.
    \item \textbf{Списък с ребрата}:

          Множеството от ребра идва като списък. Обикновено ако графът е неориентиран се пази само една пермутация на реброто.
\end{itemize}

Матрицата на съседство се използва по-рядко.
Този подход е добър, когато графите са гъсти т.е. има много ребра в тях.
В противен случай ние заемаме много повече памет от колкото ни е нужна.
За сметка на това можем да проверим дали между два върха има ребро за константно време.

Списъците на съседство са по-пестеливи от към памет в средния случай, обаче за сметка на това по-бавно се проверява съседство между два върха.
Този подход е добър, когато графите са редки т.е. имат малко ребра в тях.
Също така ако по някаква причина ни трябва да изброяваме точно съседите на някакъв връх (да кажем за някакво обхождане), това очевидно е най-добрият начин.
В най-лошия случай заемаме двойно повече памет от подхода с матрицата.

Списъка с ребрата е най-пестеливия начин от тези три.
Пази се минималното количество нужна информация.
Проблемът тук е, че проверката за съседство и изброяването на съседи на даден връх са бавни.
Обаче това представяне все пак се използва, например когато искаме да построим МПД.
Накратко, сложностите са такива:
\begin{center}
    \begin{tabular}{|c|c|c|c|}
        \hline
        подход               & памет           & $(u, v) \in E$ & изброяване на съседите \\
        \hline
        списък на съседство  & $O(|V| + |E|)$  & $O(|V|)$       & $\Theta(|N(v)|)$       \\
        \hline
        матрица на съседство & $\Theta(|V|^2)$ & $\Theta(1)$    & $\Theta(|V|)$          \\
        \hline
        списък с ребра       & $\Theta(|E|)$   & $O(|E|)$       & $\Theta(|E|)$          \\
        \hline
    \end{tabular}
\end{center}

\section{Код на алгоритмите за обхождане на графи}

Първият алгоритъм, за обхождане в широчина, е ``по-предпазлив''.
Той обхожда върховете на слоеве, започвайки с някакъв първоначален връх на слой $0$.
Намирайки се в слой $k$, ако преминем с ребро до необходен връх, ще се озовем в слой $k + 1$:
\lstinputlisting{algorithms/bfs.txt}

Сложност на алгоритъма за търсене в широчина в най-лошия случай:
\begin{itemize}
    \item по време -- $\Theta(|V| + |E|)$;
    \item по памет -- $\Theta(|E|)$.
\end{itemize}

Тук виждаме силата на представянето чрез списъци на съседство.
Ако например тук бяхме използвали матрица на съседство, алгоритъмът ни винаги щеше да има сложност $\Theta(|V|^2)$.

Нека сега разгледаме другия алгоритъм -- за обхождане в дълбочина.
Тук гледаме да влизаме колкото се може ``по-надълбоко'' в даден връх т.е. избираме произволно ребро в текущ връх докато можем, и след това се връщаме на предния и правим същото:2

\lstinputlisting{algorithms/dfs.txt}

Сложността по време и памет на алгоритъма за търсене в дълбочина е същата като на този за търсене в широчина.

\section{Задачи}

\begin{problem}
Да се напише алгоритъм, който при подаден граф намира броя на свързаните компоненти.
\end{problem}

\begin{problem}
Да се напише алгоритъм, който при подаден граф проверява дали той е цикличен.
\end{problem}

\begin{problem}
Да се напише алгоритъм, който при подаден граф проверява дали той е дърво.
\end{problem}

\begin{problem}
Да се напише алгоритъм, който при подаден (може и ориентиран) граф и два негови върха намира най-късия път между тях.
\end{problem}

\begin{problem}
Да се напише алгоритъм, който при подаден (може и ориентиран) граф, два негови върха и дължина намира броят на пътища между тях със съответната дължина.
\end{problem}

\begin{problem}
Да се напише алгоритъм, който при подаден граф проверява дали той е двуделен.
\end{problem}

\begin{problem}
Трябва да изпълним задачи $1, \dots, n$.
Обаче имаме допълнителни изисквания $R[1 \dots k]$ от вида $\opair{i, j}$, които казват \textit{``задача $i$ трябва да се изпълни преди задача $j$''}.
Да се напише алгоритъм, който при подадени изисквания намира последователност от задачи, която удовлетворява тези изисквания.
Ако няма такива, да се върне съобщение за грешка.
\end{problem}

\begin{problem}
В някакъв град има $n$ души с етикети от $0$ до $n - 1$.
Има слухове, че един от тези хора тайно е съдията на града.
Ако такъв човек има, то тогава:
\begin{itemize}
    \item съдията не вярва на никого
    \item всеки вярва на съдията, освен самия него
\end{itemize}
Масив на вярата за този град ще наричаме всеки масив $T[1 \dots k]$ от наредени двойки $\opair{i, j}$ (за $0 \leq i, j < n$), които казват \textit{``човекът с етикет $i$ вярва на човека с етикет $j$''}.
Да се напише алгоритъм, който при подаден масив на вярата, връща етикета на съдията.
Ако няма съдия, да се върне $-1$.
\end{problem}
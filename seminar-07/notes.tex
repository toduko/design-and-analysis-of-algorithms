\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english, bulgarian]{babel}
\usepackage{pgfplots}
\usepackage{amssymb}
\usepackage{hyperref, fancyhdr, lastpage, fancyvrb, tcolorbox, titlesec}
\usepackage{array, tabularx, colortbl}
\usepackage{tikz}
\usepackage{venndiagram}
\usepackage{amsthm, bm}
\usepackage{relsize}
\usepackage{amsmath,physics}
\usepackage{mathtools}
\usepackage{subcaption}
\usepackage{theoremref}
\usepackage{circuitikz}
\usepackage[a4paper, left=0.50in, right=0.50in, top=0.5in, bottom=1.0in]{geometry}
\usepackage{stmaryrd}
\usepackage[symbol]{footmisc}
\usepackage{minted}
\usepackage{enumitem}

\pgfplotsset{width=10cm,compat=1.9}

\newcommand{\N}{\mathbb{N}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\F}{\mathcal{F}}

\ExplSyntaxOn
\NewDocumentCommand{\opair}{m}
{
  \langle\mspace{2mu}
  \clist_set:Nn \l_tmpa_clist { #1 }
  \clist_use:Nn \l_tmpa_clist {,\mspace{3mu plus 1mu minus 1mu}\allowbreak}
  \mspace{2mu}\rangle
}
\ExplSyntaxOff

\hypersetup{
  colorlinks=true,
  linktoc=all,
  linkcolor=blue
}

\theoremstyle{definition}
\newtheorem{definition}{Дефиниция}[section]
\newtheorem*{warning}{\textcolor{red}{Внимание}}
\theoremstyle{plain}
\newtheorem*{theorem}{Теорема}
\newtheorem*{invariant}{Инварианта}
\newtheorem{claim}[definition]{Твърдение}
\newtheorem{axiom}[definition]{Аксиома}
\newtheorem{lemma}[definition]{Лема}
\newtheorem{corollary}[definition]{Следствие}
\theoremstyle{remark}
\newtheorem*{remark}{Забележка}
\newtheorem{problem}{Задача}
\newtheorem*{solution}{Решение}
\theoremstyle{definition}

\setlength\parindent{0pt}

\title{Приложения на сортиращите алгоритми}
\author{Тодор Дуков}
\date{}

\begin{document}
\maketitle

\section*{Два хубави алгоритъма}

Ще започнем с два често срещани алгоритъма, които се възползват от това, че данните идват сортирани:
\begin{itemize}
    \item двоично търсене
    \item алгоритъма за задачата $2$-sum
\end{itemize}

Нека започнем с алгоритъма за двоично търсене:
\inputminted[linenos]{c++}{algorithms/binary_search.cpp}

При подаден сортиран масив от числа $\mathtt{arr}$ с размер $\mathtt{n}$ и стойност $\mathtt{val}$, функцията $\mathtt{binary\_search(arr, n, val)}$ ще върне индекс на $\mathtt{arr}$, в който се намира $\mathtt{val}$, ако има такъв, иначе ще върне $\mathtt{-1}$:
\begin{invariant}
    При всяко достигане на ред $5$ имаме, че стойността $\mathtt{val}$ не се намира измежду двата масива $\mathtt{arr[0 \dots left - 1]}$ и $\mathtt{arr[right + 1 \dots n - 1]}$.
\end{invariant}

\textbf{База.}
При първото достигане имаме, че $\mathtt{left = 0}$ и $\mathtt{right = n - 1}$.
Наистина стойността $\mathtt{val}$ не се намира измежду двата масива $\mathtt{arr[0 \dots 0 -1]}$ и $\mathtt{arr[n - 1 + 1 \dots n - 1]}$.

\textbf{Поддръжка.}
Нека твърдението е изпълнено за някое непоследно достигане на ред $5$.
Тогава $\mathtt{val}$ не се намира измежду $\mathtt{arr[0 \dots left - 1]}$ и $\mathtt{arr[right + 1 \dots n - 1]}$, и понеже достигането е непоследно, $\mathtt{left \leq right}$.
Тогава $\mathtt{mid = \Bigl\lfloor \frac{left + right}{2} \Bigr\rfloor}$, откъдето $\mathtt{left \leq mid \leq right}$.
Трябва да разгледаме следните три случая:
\begin{itemize}
    \item[1 сл.] $\mathtt{arr[mid] = val}$ -- това няма как да е изпълнено понеже достигането е нефинално
    \item[2 сл.] $\mathtt{arr[mid] < val}$ -- понеже $\mathtt{arr}$ е сортиран, няма как $\mathtt{val}$ да се намира измежду $\mathtt{arr[0 \dots mid]}$, откъдето $\mathtt{val}$ не се намира измежду $\mathtt{arr[0 \dots \underbrace{\mathtt{mid + 1}}_{left_{new}} - 1]}$ и $\mathtt{arr[right + 1 \dots n - 1]}$.
    \item[3 сл.] $\mathtt{arr[mid] > val}$ -- напълно дуален на 2 сл.
\end{itemize}

\textbf{Терминация.}
От цикъла можем да излезем по два начина:
\begin{itemize}
    \item не е изпълнено условието на ред $5$ т.е. $\mathtt{left > right}$ -- тогава $\mathtt{left - 1 \geq right}$ и понеже $\mathtt{val}$ не се намира измежду $\mathtt{arr[0 \dots left - 1]}$ и $\mathtt{arr[right + 1 \dots n - 1]}$, $\mathtt{val}$ не се намира във $\mathtt{arr[0 \dots n - 1]}$.
          Накрая алгоритъмът ще върне $\mathtt{-1}$, което наистина е желания резултат.
    \item изпълнено е условието на ред $9$ т.е. $\mathtt{arr[mid] = val}$ -- тогава алгоритъмът връща $\mathtt{mid}$ т.е. точно това, което искаме.
\end{itemize}

Нека сега разгледаме алгоритъма за задачата $2$-sum:
\inputminted[linenos]{c++}{algorithms/two_sum.cpp}

Ще покажем, че при подаден сортиран масив $\mathtt{arr}$ с размер $\mathtt{n}$ и число $\mathtt{target}$, функцията $\mathtt{two\_sum(arr, n, target)}$ разпознава дали има $\mathtt{0 \leq i < j \leq n - 1}$, за които:
\[
    \mathtt{arr[i] + arr[j] = target} \text{ // всяка такава двойка } \mathtt{(i, j)} \text{ ще наричаме \textit{диада}}
\]
\begin{invariant}
    При всяко достигане на ред $5$ имаме, че всички диади се намират в $\mathtt{arr[left \dots right]}$.
\end{invariant}

\textbf{База.}
При първото достигане имаме, че $\mathtt{left = 0}$ и $\mathtt{right = n - 1}$.
Тогава твърдението е тривиално изпълнено.

\textbf{Поддръжка.}
Нека твърдението е изпълнено за някое непоследно достигане на ред $5$.
Тогава всички диади се намират в $\mathtt{arr[left \dots right]}$ и понеже достигането е непоследно, $\mathtt{left < right}$.
Трябва да разгледаме следните три случая:
\begin{itemize}
    \item[1 сл.] $\mathtt{arr[left] + arr[right] = target}$ -- това няма как да е изпълнено понеже достигането е нефинално
    \item[2 сл.] $\mathtt{arr[left] + arr[right] < target}$ -- тогава понеже $\mathtt{arr}$ е сортиран, за всяко $\mathtt{left + 1 \leq i \leq right}$ имаме, че $\mathtt{arr[left] + arr[i] \leq arr[left] + arr[right] < target}$.
        Това означава, че $\mathtt{left}$ не участва в никоя диада във $\mathtt{arr[left \dots right]}$.
        Така получаваме, че всички диади се намират в $\mathtt{arr[\underbrace{\mathtt{left + 1}}_{left_{new}} \dots right]}$
    \item[3 сл.] $\mathtt{arr[left] + arr[right] > target}$ -- напълно дуален на 2 сл.
\end{itemize}

\textbf{Терминация.}
От цикъла можем да излезем по два начина:
\begin{itemize}
    \item не е изпълнено условието на ред $5$ т.е. $\mathtt{left \geq right}$ -- тогава няма диади в $\mathtt{arr}$, и алгоритъмът коректно ще върне $\mathtt{false}$.
    \item изпълнено е условието на ред $9$ т.е. $\mathtt{arr[left] + arr[right] = target}$ -- тогава алгоритъмът връща $\mathtt{true}$ т.е. точно това, което искаме.
\end{itemize}

Двата алгоритъма са доста подобни, използват една често срещана техника -- two-pointer.
Това е много силен метод за решаване на задачи за търсене в някакво множество от елементи.
Започва се с цялото множество и то постепенно се смалява.
Разбира се, тук разгледаните алгоритми имат разлика в сложността, поради разликата в стесняването:
\begin{itemize}
    \item първият алгоритъм има сложност $O(\log(n))$ понеже винаги разликата между $\mathtt{left}$ и $\mathtt{right}$ намалява двойно
    \item вторият алгоритъм има сложност $O(n)$ понеже винаги разликата между $\mathtt{left}$ и $\mathtt{right}$ намалява с единица
\end{itemize}

\section*{Задачи}

\begin{problem}
Да се напише колкото се може по-бърз алгоритъм $\mathtt{find\_peak(arr, n)}$, който приема масив от различни числа $\mathtt{arr}$ с размер $\mathtt{n \geq 3}$, за който има $\mathtt{0 < i < n - 1}$ такова, че $\mathtt{arr[0 \dots i]}$ е сортиран възходящо и $\mathtt{arr[i \dots n - 1]}$ е сортиран низходящо, и връща това $\mathtt{i}$.
След това да се докаже неговата коректност, и да се изследва сложността му по време.
\end{problem}

\begin{problem}
Да се напише колкото се може по-бърз алгоритъм $\mathtt{search\_range(arr, n, val)}$, който при подаден сортиран масив $\mathtt{arr}$ с размер $\mathtt{n}$ и число $\mathtt{val}$, което се намира в масива, връща най-малкият и най-големият индекс, на който $\mathtt{val}$ се намира в $\mathtt{arr}$.
След това да се докаже неговата коректност, и да се изследва сложността му по време.
\end{problem}

\begin{problem}
Да се напише колкото се може по-бърз алгоритъм $\mathtt{k\_sum(arr, n, k, target)}$, който при подаден сортиран масив $\mathtt{arr}$ с размер $\mathtt{n}$ и числа $\mathtt{k \geq 2}$ и $\mathtt{target}$, връща дали има $\mathtt{0 \leq i_1 < i_2 < \dots < i_k \leq n - 1}$, за които:
\[
    \mathtt{arr[i_1] + arr[i_2] + \dots + arr[i_k] = target}
\]
След това да се докаже неговата коректност, и да се изследва сложността му по-време.
\end{problem}

\begin{problem}
Да се напише колкото се може по-бърз алгоритъм $\mathtt{k\_closest(arr, n, k, target)}$, който принтира най-близките $\mathtt{k}$ числа в $\mathtt{arr}$ до $\mathtt{target}$.
След това да се докаже неговата коректност, и да се изследва сложността му по време.
Може ли да се напише по-бърз алгоритъм при предположение че $\mathtt{arr}$ е сортиран?
\end{problem}

\begin{problem}
Да се напише колкото се може по-бърз алгоритъм $\mathtt{sort(arr, n)}$, който приема масив $\mathtt{arr}$ с размер $\mathtt{n}$, съставен от числата $\mathtt{0, 1}$ и $\mathtt{2}$, и го сортира.
След това да се докаже неговата коректност, и да се изследва сложността му по време.
\end{problem}

\begin{problem}
Да се напише колкото се може по-бърз алгоритъм $\mathtt{merge\_intervals(intervals, n)}$, който приема масив $\mathtt{intervals}$ с размер $\mathtt{n}$, съставен от двойки числа, които представят някакъв затворен интервал, и връща нов масив, в който са сляти всички интервали с непразно сечение.
След това да се докаже неговата коректност, и да се изследва сложността му по време.
\end{problem}

\begin{problem}
Да се напише колкото се може по-бърз алгоритъм $\mathtt{sorted\_squares(arr, n)}$, който приема масив $\mathtt{arr}$ с размер $\mathtt{n}$, и връща нов масив от квадратите на $\mathtt{arr}$, който е сортиран.
След това да се докаже неговата коректност, и да се изследва сложността му по време.
\end{problem}

\end{document}

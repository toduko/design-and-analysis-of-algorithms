\chapter{Динамично програмиране}

\section{Какво е динамично програмиране?}

Динамичното програмиране не е нито динамично, нито програмиране.
Това е както оптимизационен метод, така и алгоритмична парадигма, която е разработена от Ричард Белман през 50-те години на миналия век.
В този метод една зачача се разделя на подзадачи по рекурсивен начин.
Той се използва в два случая:
\begin{itemize}
    \item при задачи, които имат припокриваща се подструктура т.е. задачата се разделя на подзадачи, които се срещат няколко пъти;
    \item при задачи, които имат оптимална подструктура т.е. оптимално решение може да се конструира от оптимални решения на подзадачите.
\end{itemize}

\section{Прости примери за динамично програмиране}

Да кажем, че искаме да сметнем $n$-тото число на Фибоначи.
Един начин е да караме по рекурентното уравнение:
\lstinputlisting{algorithms/fib-slow.txt}
Проблемът е, че получаваме експоненциална сложност по време.
Нещо, което можем да направим, е да пазим вече пресметнатите стойности, за да не се налага да ги пресмятаме пак:
\lstinputlisting{algorithms/fib-dp.txt}
Това е пример за задача с припокриваща се подструктура, с решение по схемата \textbf{динамично програмиране}.
Успяхме да решим задачата за линейно време.

Нека сега видим пример за задача с оптимална подструктура.
Да кажем, че имаме два низа $S_1[1 \dots n]$ и $S_2[1 \dots m]$ и искаме да пресметнем дължината на най-дългата обща подредица на $S_1$ и $S_2$.
Лесно се вижда, че дължината $\operatorname{LCS}_{S_1, S_2}(i, j)$ на най-дългата подредица на $S_1[1 \dots i]$ и $S_2[1 \dots j]$ може да се пресметне рекурсивно така:
\[
    \operatorname{LCS}_{S_1, S_2}(i, j) = \begin{cases}
        0                                                                                          & \text{, ако } i = 0 \text{ или } j = 0               \\
        \operatorname{LCS}_{S_1, S_2}(i - 1, j - 1) + 1                                            & \text{, ако } i, j > 0 \text{ и } S_1[i] = S_2[j]    \\
        \max\{ \operatorname{LCS}_{S_1, S_2}(i - 1, j), \operatorname{LCS}_{S_1, S_2}(i, j - 1) \} & \text{, ако } i, j > 0 \text{ и } S_1[i] \neq S_2[j]
    \end{cases}
\]
Ако искаме да пресметнем това със обикновена рекурсия, отново ще получим експоненциална сложност по време.
Отново можем да направим решение по схемата \textbf{динамично програмиране} със сложност $\Theta(n \cdot m)$.
Единственото, което трябва да се направи, е да се измисли последователност за пресмятане на:
\[
    \begin{pmatrix}
        \operatorname{LCS}_{S_1, S_2}(0, 0) & \dots  & \operatorname{LCS}_{S_1, S_2}(n, 0) \\
        \vdots                              & \ddots & \vdots                              \\
        \operatorname{LCS}_{S_1, S_2}(m, 0) & \dots  & \operatorname{LCS}_{S_1, S_2}(n, m)
    \end{pmatrix}
\]
Важно е да искаме преди пресмятането на всяка клетка, необходимите за нея данни вече са готови.
Ето как може да стане това:
\lstinputlisting{algorithms/longest-common-subsequence.txt}

\section{Динамично програмиране за решаване на комбинаторни задачи}

Вижда се, че тази техника е много удобна за бързо пресмятане на рекурентни зависимости.
Едно приложение е в решаването на комбинаторни задачи.
Да кажем, че искаме да пресметнем бързо ${n \choose k}$.

Нека първо си припомним дефиницията:
\[
    {n \choose k} = \frac{n!}{k! (n - k)!}.
\]

Ние ще пресметнем ${n \choose k}$ точно по този начин.
За тази цел единственото нещо, което се иска да сметнем трите стойности -- $n!, k!$ и $(n - k)!$.

\newpage

Това става елементарно по следния начин:
\lstinputlisting{algorithms/binomial-factorial.txt}
Получихме сложност по време $\Theta(n)$ т.е. имаме сравнително бързо решение.
Обаче то не е практично.
Проблемът е, че функцията $n!$ расте много бързо.
Ние ще работим с големи стойности във $F[0 \dots n]$, но крайният отговор ще е много по-малък от това.
Ако искаме да си гарантираме възможно най-малки стойности по време на изчисление, трябва да го пресметнем за време $\Theta(n \cdot k)$ чрез формулата:
\[
    {n \choose k} = {n - 1 \choose k - 1} + {n - 1 \choose k}.
\]

Нека сега се опитаме да пресметнем броят $T_n$\footnote{Тези числа се наричат числа на Каталан.} на двоични дървета за търсене с $n$ различни върха.
При $n = 0$ положението е ясно.
Ако $n \geq 1$, то имаме няколко случая в зависимост от това кой връх е корен на дървото.
Броят на двоичните дървета за търсене с корен $i$-тия по големина връх, където $1 \leq i \leq n$, е равен на броя двоичните дървета с $(i - 1)$-те по-малки от него върха, умножен по броя на двоичните дървета с останалите $n - i$ върха.
Това е точно $T_{i - 1} \cdot T_{n - i}$.
Така получаваме следното рекурентно уравнение:
\begin{align*}
    T_0 & = 1                                                                 \\
    T_n & = \sum\limits_{i = 1}^n T_{i - 1} \cdot T_{n - i} \text{ за } n > 0
\end{align*}
Ясно е, че не искаме да пресмятаме $T_n$ чрез рекурсия -- това би било кошмарно бавно.

\newpage

Отново ще помним предишни изчисления, за да си забързаме алгоритъма до такъв със сложност $\Theta(n^2)$:
\lstinputlisting{algorithms/catalan.txt}

\section{Задачи}

\begin{problem}
Да се напише колкото се може по-бърз алгоритъм, който пресмята ${n \choose k}$ с рекурентната формула от по-горе.
След това да се докаже неговата коректност, и да се изследва сложността му по време.
\end{problem}

\begin{problem}
Да се напише колкото се може по-бърз алгоритъм, който при подадено естествено число $n$, намира броят на начини човек да се изкачи по тях, като може да изкачва най-много $3$ стъпала наведнъж.
След това да се докаже неговата коректност, и да се изследва сложността му по време.
\end{problem}

\begin{problem}
Да се напише колкото се може по-бърз алгоритъм, който при подадена булева матрица $A[1 \dots n, 1 \dots m]$ намира броя на пътищата (движейки се само надясно и надолу) от $(1, 1)$ до $(n, m)$, които не минават през $1$ в $A$.
След това да се докаже неговата коректност, и да се изследва сложността му по време.
\end{problem}

\begin{problem}
Да се напише колкото се може по-бърз алгоритъм, който при подадена матрица от естествени числа $A[1 \dots n, 1 \dots m]$ намира минималната цена на път (движейки се само надясно и надолу) от $(1, 1)$ до $(n, m)$, като под цена на път разбираме сумата на всичките $A[i, j]$, срещнати по пътя.
След това да се докаже неговата коректност, и да се изследва сложността му по време.
\end{problem}


\begin{problem}
Да се напише колкото се може по-бърз алгоритъм, който при подаден целочислен масив $A[1 \dots n]$ намира дължината на най-дългата строго растяща негова подредица.
След това да се докаже неговата коректност, и да се изследва сложността му по време.
\end{problem}

\begin{problem}
Да се напише колкото се може по-бърз алгоритъм, който при подаден масив от естествени числа $A[1 \dots n]$ и естествено число $s$ намира броя на начините, по които могат да се изберат елементи на $A$, така че да сумата им да е $s$.
След това да се докаже неговата коректност, и да се изследва сложността му по време.
\end{problem}

\begin{problem}
За масив от положителни числа $A[1 \dots n]$ и $1 \leq i < j \leq n$ казваме, че можем да стигнем от $i$ до $j$ в $A$ за една стъпка, ако и $j - i \leq A[i]$.
Да се напише колкото се може по-бърз алгоритъм, който при подаден масив от положителни числа $A[1 \dots n]$ намира минималния брой стъпки, с който можем да стигнем от $1$ до $n$ в $A$.
След това да се докаже неговата коректност, и да се изследва сложността му по време.
\end{problem}

\begin{problem}
Да се напише колкото се може по-бърз алгоритъм, който при подадено $n$ и число $k$ пресмята броят на начините да се стигне до $k$ чрез хвърляния на зар с $n$ страни, на които пише числата от $1$ до $n$.
След това да се докаже неговата коректност, и да се изследва сложността му по време.
\end{problem}
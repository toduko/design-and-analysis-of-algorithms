\chapter{Приложения на сортиращите алгоритми}

\section{Обща информация за някои алгоритми за сортиране}

Понякога се оказва много удобно да сортираме входните данни, защото това ни носи полезна информация.
Затова е хубаво да се знаят различните алгоритми за сортиране и в какво те са добри.
Нека ги сравним по тяхната сложност, като:
\begin{itemize}
    \item $T_{avg}(n)$ е сложността по време в средния случай;
    \item $M_{avg}(n)$ е сложността по памет в средния случай;
    \item $T_{worst}(n)$ е сложността по време в най-лошия случай;
    \item $M_{worst}(n)$ е сложността по памет в най-лошия случай.
\end{itemize}

\begin{center}
    \begin{tabular}{| c | c | c | c | c |}
        \hline
        име                    & $T_{avg}(n)$        & $M_{avg}(n)$      & $T_{worst}(n)$      & $M_{worst}(n)$ \\
        \hline
        пирамидално сортиране  & $\Theta(n \log(n))$ & $\Theta(1)$       & $\Theta(n \log(n))$ & $\Theta(1)$    \\
        \hline
        сортиране чрез сливане & $\Theta(n \log(n))$ & $\Theta(n)$       & $\Theta(n \log(n))$ & $\Theta(n)$    \\
        \hline
        бързо сортиране        & $\Theta(n \log(n))$ & $\Theta(\log(n))$ & $\Theta(n^2)$       & $\Theta(n)$    \\
        \hline
    \end{tabular}
\end{center}

Въпреки че алгоритъмът за бързо сортиране е по-бавен в най-лошия случай от пирамидалното сортиране и сортирането чрез сливане, практически се оказва, че се справя по-добре.
Разбира се, другите сортировки също имат предимства.
Пирамидалното сортиране заема малко памет, което е много полезно във вградени системи.
Сортирането чрез сливане се оказва по-бързо, когато данните са много големи и се съхраняват във външни устройства (да кажем, на твърд диск).
Освен тези алгоритми има и други хубави алгоритми като сортиране чрез броене, но за съжаление ние няма да ги разглеждаме тук.

\section{Два алгоритъма}

Ще започнем с два често срещани алгоритъма, които се възползват от това, че данните идват сортирани:
\begin{itemize}
    \item двоично търсене;
    \item алгоритъма за задачата \textbf{2SUM}.
\end{itemize}

Нека започнем с алгоритъма за двоично търсене:
\lstinputlisting{algorithms/binary-search.txt}

При подаден сортиран целочислен масив $A[1 \dots n]$ и цяло число $v$, функцията $\mathtt{BinarySearch}(A[1 \dots n], v)$ ще върне индекс на $A[1 \dots n]$, в който се намира $v$, ако има такъв, иначе ще върне $-1$.

\newpage

\begin{invariant}
    При всяко достигане на проверката за край на цикъла на ред $6$ имаме, че стойността $v$ не се намира измежду двата масива $A[1 \dots l - 1]$ и $A[r + 1 \dots n]$.
\end{invariant}

\begin{proof}
    \phantom{1}

    \textbf{База.}
    При първото достигане имаме, че $l = 1$ и $r = n$.
    Наистина $v$ не се намира измежду двата масива $A[1 \dots 1 - 1]$ и $A[n + 1 \dots n]$.

    \textbf{Поддръжка.}
    Нека твърдението е изпълнено за някое непоследно достигане на проверката за край на цикъла.
    Тогава $v$ не се намира измежду $A[1 \dots l - 1]$ и $A[r + 1 \dots n]$, и понеже достигането е непоследно, $l \leq r$.
    Тогава $m = \Bigl\lfloor \frac{l + r}{2} \Bigr\rfloor$, откъдето ${l \leq m \leq r}$.
    Трябва да разгледаме следните три случая:
    \begin{itemize}
        \item[1 сл.] $A[m] = v$ -- това няма как да е изпълнено понеже достигането е нефинално;
        \item[2 сл.] $A[m] < v$ -- понеже $A[1 \dots n]$ е сортиран, няма как $v$ да се намира измежду $A[1 \dots m]$, откъдето $v$ не се намира измежду $A[1 \dots \underbrace{\mathtt{m + 1}}_{l_{new}} - 1]$ и $A[r + 1 \dots n]$;
        \item[3 сл.] $A[m] > v$ -- напълно дуален на 2 сл.
    \end{itemize}

    \textbf{Терминация.}
    От цикъла винаги ще излезем, защото или ще открием $v$, или величината $r - l$ ще намалява, докато не стане отрицателна.
    Излизането става по два начина:
    \begin{itemize}
        \item Ако не е изпълнено условието на ред $6$ т.е. $l > r$, то тогава $l - 1 \geq r$ и понеже $v$ не се намира измежду $A[1 \dots l - 1]$ и $A[r + 1 \dots n]$, $v$ не се намира във $A[1 \dots n]$.
              Накрая алгоритъмът ще върне $-1$, което наистина е желания резултат.
        \item Ако е изпълнено е условието на ред $9$ т.е. $A[m] = v$, то тогава алгоритъмът коректно връща $m$.
    \end{itemize}
\end{proof}

Сега ще разгледаме алгоритъм за задачата \textbf{2SUM}.

Ще искаме алгоритъм, който при подаден сортиран целочислен масив $A[1 \dots n]$ и цяло число $t$ разпознава дали има $1 \leq i < j \leq n$, за които:
\[
    A[i] + A[j] = t.
\]
Такива двойки $(A[i], A[j])$ ще наричаме \textit{диади}.

\newpage

Алгоритъмът е следния:
\lstinputlisting{algorithms/two-sum.txt}

\begin{invariant}
    При всяко достигане на проверката за край на цикъла на ред $5$, всички диади са в $A[l \dots r]$.
\end{invariant}

\begin{proof}
    \phantom{1}

    \textbf{База.}
    При първото достигане имаме, че $l = 1$ и $r = n$.
    Тогава твърдението е тривиално изпълнено.

    \textbf{Поддръжка.}
    Нека твърдението е изпълнено за някое непоследно достигане на проверката за край на цикъла.
    Тогава всички диади са в $A[l \dots r]$ и $l < r$.
    Разглеждаме три случая:
    \begin{itemize}
        \item[1 сл.] $A[l] + A[r] = t$ -- това няма как да е изпълнено понеже достигането е нефинално;
        \item[2 сл.] $A[l] + A[r] < t$ -- тогава понеже $A[1 \dots n]$ е сортиран, за всяко $l \leq i \leq r$ имаме, че $A[l] + A[i] \leq A[l] + A[r] < t$, което означава, че $l$ не участва в никоя диада във $A[l \dots r]$, следователно всички диади се намират в $A[\underbrace{l + 1}_{l_{new}} \dots r]$;
        \item[3 сл.] $A[l] + A[r] > t$ -- напълно дуален на 2 сл.
    \end{itemize}

    \textbf{Терминация.}
    От цикъла винаги ще излезем, защото или ще открием $v$, или величината $r - l$ ще намалява, докато не стане $0$.
    Излизането става по два начина:
    \begin{itemize}
        \item Ако не е изпълнено условието на ред $4$ т.е. $l \geq r$, то тогава няма диади в $A[1 \dots n]$, и алгоритъмът коректно ще върне $\F$.
        \item Ако е изпълнено условието на ред $5$ т.е. $A[l] + A[r] = t$, то тогава алгоритъмът връща $\T$ т.е. точно това, което искаме.
    \end{itemize}
\end{proof}

Двата алгоритъма са доста подобни, използват една често срещана техника за търсене в дадено множество от елементи.
Търсенето започва с цялото множество и то постепенно се смалява.
Разбира се, тук разгледаните алгоритми имат разлика в сложността, поради разликата в стесняването:
\begin{itemize}
    \item първият алгоритъм има сложност $O(\log(n))$, понеже разликата между $r$ и $l$ винаги намалява двойно;
    \item вторият алгоритъм има сложност $O(n)$, понеже разликата между $r$ и $l$ винаги намалява с единица.
\end{itemize}

\section{Задачи}

\begin{problem}
Да се напише колкото се може по-бърз алгоритъм, който приема масив от различни цели числа $A[1 \dots n]$ с $n \geq 3$, за който има $1 < i < n$ такова, че $A[1 \dots i]$ е сортиран възходящо и $A[i \dots n]$ е сортиран низходящо, и връща това $i$.
След това да се докаже неговата коректност, и да се изследва сложността му по време.
\end{problem}

\begin{problem}
Да се напише колкото се може по-бърз алгоритъм, който при подаден сортиран целочислен масив $A[1 \dots n]$ и число $t$, което се намира в масива, връща най-малкият и най-големият индекс, на които $t$ се намира в $A[1 \dots n]$.
След това да се докаже неговата коректност, и да се изследва сложността му по време.
\end{problem}

\begin{problem}
Да се напише колкото се може по-бърз алгоритъм, който при подаден сортиран целочислен масив $A[1 \dots n]$ и числа $k \geq 2$ и $t$, връща дали има $0 \leq i_1 < i_2 < \dots < i_k \leq n - 1$, за които:
\[
    A[i_1] + A[i_2] + \dots + A[i_k] = t.
\]
След това да се докаже неговата коректност, и да се изследва сложността му по време.
\end{problem}

\begin{problem}
За $a, b, x \in \mathbb{Z}$ казваме, че $a$ е по-близо от $b$ до $x$, ако:
\[
    |a - x| < |b - x| \lor (|a - x| = |b - x| \: \& \: a < b).
\]
Да се напише колкото се може по-бърз алгоритъм, който приема целочислен масив $A[1 \dots n]$, и връща най-близките $k$ на брой числа до $t$ в $A[1 \dots n]$.
След това да се докаже неговата коректност, и да се изследва сложността му по време.
Може ли да се напише по-бърз алгоритъм при предположение че $A[1 \dots n]$ е сортиран?
\end{problem}

\begin{problem}
Да се напише колкото се може по-бърз алгоритъм, който приема масив $A[1 \dots n]$, съставен от числата $0, 1$ и $2$, и го сортира.
След това да се докаже неговата коректност, и да се изследва сложността му по време.
\end{problem}

\begin{problem}
Да се напише колкото се може по-бърз алгоритъм, който приема масив $I[1 \dots n]$, съставен от двойки числа, които представят някакъв затворен интервал от цели числа ($[a, b]$ за някои $a, b \in \mathbb{Z}$), и връща нов масив, в който са сляти всички интервали с непразно сечение.
След това да се докаже неговата коректност, и да се изследва сложността му по време.
\end{problem}

\begin{problem}
Да се напише колкото се може по-бърз алгоритъм, който приема целочислен масив $A[1 \dots n]$, и връща нов масив от квадратите на $A[1 \dots n]$, който е сортиран.
След това да се докаже неговата коректност, и да се изследва сложността му по време.
\end{problem}

\begin{problem}
Да се напише колкото се може по-бърз алгоритъм, който приема целочислен масив $A[1 \dots 2n]$, и връща:
\[
    \min\{ \max \{ A'[2i] + A'[2i - 1] \mid 1 \leq i \leq n \} \mid A'[1 \dots n] \text{ е пермутация на } A[1 \dots n] \}.
\]
След това да се докаже неговата коректност, и да се изследва сложността му по време.
\end{problem}

\begin{problem}
Да се напише колкото се може по-бърз алгоритъм, който приема два целочислени масива $A[1 \dots n]$ и $B[1 \dots n]$, и връща:
\begin{align*}
    \min \{ \sum\limits_{i = 1}^n |A'[i] - B'[i]| \mid & A'[1 \dots n] \text{ е пермутация на } A[1 \dots n] \text{ и} \\
                                                       & B'[1 \dots n] \text{ е пермутация на } B[1 \dots n] \}.
\end{align*}
След това да се докаже неговата коректност, и да се изследва сложността му по време.
\end{problem}

\begin{problem}
Да се напише колкото се може по-бърз алгоритъм, който приема целочислен масив $A[1 \dots n]$ и го подрежда така, че всички отрицателни числа да са вляво от всички неотрицателни.
След това да се докаже неговата коректност и да се изследва сложността му по време и памет.
\end{problem}